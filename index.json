[{"categories":null,"content":"一、Spring简介 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:1:0","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"1 Spring介绍 问题导入 我们为什么要学习Spring框架？ 1.1 为什么要学 Spring技术是JavaEE开发必备技能，企业开发技术选型命中率\u003e==90%== 专业角度 ==简化开发==，降低企业级开发的复杂性 ==框架整合==，高效整合其他技术，提高企业级应用开发与运行效率 1.2 学什么 简化开发 ==IOC(反转控制)== ==AOP(面向切面编程)== ==事务处理== 框架整合 MyBatis MyBatis-plus Struts Struts2 Hibernate …… 1.3 怎么学 学习Spring框架设计思想 学习基础操作，思考操作与思想间的联系 学习案例，熟练应用操作的同时，体会思想 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:1:1","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"2 初识Spring 问题导入 目前我们使用的是Spring几版本？ 2.1 Spring家族 官网：https://spring.io Spring发展到今天已经形成了一种开发的生态圈，Spring提供了若干个项目，每个项目用于完成特定的功能。 2.2 Spring发展史 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:1:2","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"3 Spring体系结构 问题导入 通过系统架构6图，Spring能不能进行数据层开发？Spring能不能进行web层开发？ 3.1 Spring Framework系统架构图 Spring Framework是Spring生态圈中最基础的项目，是其他项目 的根基 3.2 Spring Framework课程学习路线 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:1:3","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"4 Spring核心概念 问题导入 问题1：目前我们的代码存在什么问题以及怎么解决这些问题？ 问题2：请描述什么是IOC，什么是DI？ 4.1 目前我们代码存在的问题 代码书写现状 耦合度偏高 解决方案 使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象 4.2 核心概念 ==IOC（Inversion of Control）控制反转== 使用对象时，由主动new产生对象转换为由==外部==提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。通俗的讲就是“==将new对象的权利交给Spring，我们从Sprin g中获取对象使用即可==” Spring技术对IoC思想进行了实现 Spring提供了一个容器，称为==IOC容器==，用来充当IoC思想中的“外部” IOC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为==Bean== ==DI（Dependency Injection）依赖注入== 在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入。 目标：充分解耦 使用IoC容器管理bean（IOC) 在IoC容器内将有依赖关系的bean进行关系绑定（DI） 最终效果 使用对象时不仅可以直接从IoC容器中获取，并且获取到的bean已经绑定了所有的依赖关系 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:1:4","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"二、IOC和DI入门案例【重点】 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:2:0","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"1 IOC入门案例【重点】 问题导入 \u003cbean\u003e标签中id属性和class属性的作用是什么？ 1.1 门案例思路分析 管理什么？(Service与Dao) 如何将被管理的对象告知IOC容器？(配置文件) 被管理的对象交给IOC容器，如何获取到IoC容器？(接口) IOC容器得到后，如何从容器中获取bean？(接口方法) 使用Spring导入哪些坐标？(pom.xml) 1.2 实现步骤 【第一步】导入Spring坐标 【第二步】定义Spring管理的类（接口） 【第三步】创建Spring配置文件，配置对应类作为Spring管理的bean对象 【第四步】初始化IOC容器（Spring核心容器/Spring容器），通过容器获取bean对象 1.3 实现代码 【第一步】导入Spring坐标 先配置依赖才能创建spring配置文件 \u003cdependencies\u003e \u003c!--导入spring的坐标spring-context，对应版本是5.2.10.RELEASE--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context\u003c/artifactId\u003e \u003cversion\u003e5.2.10.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 【第二步】定义Spring管理的类（接口） BookDao接口和BookDaoImpl实现类 public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } } BookService接口和BookServiceImpl实现类 public interface BookService { public void save(); } public class BookServiceImpl implements BookService { private BookDao bookDao = new BookDaoImpl(); public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 【第三步】创建Spring配置文件，配置对应类作为Spring管理的bean对象 定义applicationContext.xml配置文件并配置BookServiceImpl \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!-- bean标签：表示配置bean id属性：表示给bean起名字 class属性：表示给bean定义类型 --\u003e \u003cbean id=\"bookService\" class=\"com.itheima.service.impl.BookServiceImpl\"\u003e\u003c/bean\u003e \u003c/beans\u003e ==注意事项：bean定义时id属性在同一个上下文中(IOC容器中)不能重复== 【第四步】初始化IOC容器（Spring核心容器/Spring容器），通过容器获取Bean对象 public class App { public static void main(String[] args) { //1.创建IoC容器对象，加载spring核心配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2 从IOC容器中获取Bean对象(BookService对象) BookService bookService= (BookService)ctx.getBean(\"bookService\"); //3 调用Bean对象(BookService对象)的方法 bookService.save(); } } 1.4 运行结果 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:2:1","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"2 DI入门案例【重点】 问题导入 \u003cproperty\u003e标签中name属性和ref属性的作用是什么？ 2.1 DI入门案例思路分析 基于IOC管理bean Service中使用new形式创建的Dao对象是否保留？(否) Service中需要的Dao对象如何进入到Service中？(提供方法) Service与Dao间的关系如何描述？(配置) 2.2 实现步骤 【第一步】删除使用new的形式创建对象的代码 【第二步】提供依赖对象对应的setter方法 【第三步】配置service与dao之间的关系 2.3 实现代码 【第一步】删除使用new的形式创建对象的代码 public class BookServiceImpl implements BookService { private BookDao bookDao; //【第一步】删除使用new的形式创建对象的代码 public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 【第二步】提供依赖对象对应的setter方法 public class BookServiceImpl implements BookService { private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } //【第二步】提供依赖对象对应的setter方法 public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } } 【第三步】配置service与dao之间的关系 在applicationContext.xml中配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!-- bean标签：表示配置bean id属性：表示给bean起名字 class属性：表示给bean定义类型 --\u003e \u003cbean id=\"bookDao\" class=\"com.itheima.dao.impl.BookDaoImpl\"/\u003e \u003cbean id=\"bookService\" class=\"com.itheima.service.impl.BookServiceImpl\"\u003e \u003c!--配置server与dao的关系 property标签：表示配置当前bean的属性 name属性：表示配置哪一个具体的属性 ref属性：表示参照哪一个bean --\u003e \u003cproperty name=\"bookDao\" ref=\"bookDao\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 2.4 图解演示 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:2:2","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"三、Bean的基础配置 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:3:0","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"问题导入 问题1：在\u003cbean\u003e标签上如何配置别名？ 问题2：Bean的默认作用范围是什么？如何修改？ ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:3:1","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"1 Bean基础配置【重点】 配置说明 代码演示 见《IOC入门案例》applicationContext.xml配置 运行结果 见《IOC入门案例》运行结果 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:3:2","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"2 Bean别名配置 配置说明 代码演示 打印结果 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:3:3","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"3 Bean作用范围配置【重点】 配置说明 扩展：scope的取值不仅仅只有singleton和prototype，还有request、session、application、 websocket ，表示创建出的对象放置在web容器(tomcat)对应的位置。比如：request表示保存到request域中。 代码演示 打印结果 最后给大家说明一下：在我们的实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性。 适合交给容器管理的bean 表现层对象 业务层对象 数据层对象 工具对象 不适合交给容器管理的对象 封装实体的域对象 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:3:4","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"四、Bean的实例化 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:4:0","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"问题导入 Bean的实例化方式有几种？ ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:4:1","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"1 Bean是如何创建的【理解】 bean本质上就是对象，创建bean使用构造方法完成 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:4:2","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"2 实例化Bean的三种方式 2.1 构造方法方式【重点】 BookDaoImpl实现类 public class BookDaoImpl implements BookDao { public BookDaoImpl() { System.out.println(\"book dao constructor is running ....\"); } public void save() { System.out.println(\"book dao save ...\"); } } applicationContext.xml配置 \u003c!--方式一：构造方法实例化bean--\u003e \u003cbean id=\"bookDao\" class=\"com.itheima.dao.impl.BookDaoImpl\"/\u003e AppForInstanceBook测试类 public class AppForInstanceBook { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); bookDao.save(); } } 运行结果 ==注意：无参构造方法如果不存在，将抛出异常BeanCreationException== 2.2 静态工厂方式 OrderDao接口和OrderDaoImpl实现类 public interface OrderDao { public void save(); } public class OrderDaoImpl implements OrderDao { public void save() { System.out.println(\"order dao save ...\"); } } OrderDaoFatory工厂类 //静态工厂创建对象 public class OrderDaoFactory { public static OrderDao getOrderDao(){ System.out.println(\"factory setup....\"); return new OrderDaoImpl(); } } applicationContext.xml配置 \u003c!--方式二：使用静态工厂实例化bean--\u003e \u003cbean id=\"orderDao\" class=\"com.itheima.factory.OrderDaoFactory\" factory-method=\"getOrderDao\"/\u003e AppForInstanceOrder测试类 public class AppForInstanceOrder { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); OrderDao orderDao = (OrderDao) ctx.getBean(\"orderDao\"); orderDao.save(); } } 运行结果 2.3 实例工厂方式 UserDao接口和UserDaoImpl实现类 public interface UserDao { public void save(); } public class UserDaoImpl implements UserDao { public void save() { System.out.println(\"user dao save ...\"); } } UserDaoFactory工厂类 //实例工厂创建对象 public class UserDaoFactory { public UserDao getUserDao(){ return new UserDaoImpl(); } } applicationContext.xml配置 \u003c!--方式三：使用实例工厂实例化bean--\u003e \u003cbean id=\"userFactory\" class=\"com.itheima.factory.UserDaoFactory\"/\u003e \u003cbean id=\"userDao\" factory-method=\"getUserDao\" factory-bean=\"userFactory\"/\u003e AppForInstanceUser测试类 public class AppForInstanceUser { public static void main(String[] args) { // //创建实例工厂对象 // UserDaoFactory userDaoFactory = new UserDaoFactory(); // //通过实例工厂对象创建对象 // UserDao userDao = userDaoFactory.getUserDao(); // userDao.save(); ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDao) ctx.getBean(\"userDao\"); userDao.save(); } } 运行结果 2.4 实现FactoryBean\u003cT\u003e方式【扩展,了解】 定义UserDaoFactoryBean实现FactoryBean\u003cUserDao\u003e UserDaoFactoryBean中实例化什么类型的对象泛型就是该类型。 //FactoryBean创建对象 public class UserDaoFactoryBean implements FactoryBean\u003cUserDao\u003e { //代替原始实例工厂中创建对象的方法 public UserDao getObject() throws Exception { return new UserDaoImpl(); } public Class\u003c?\u003e getObjectType() { return UserDao.class; } } applicationContext.xml配置 \u003c!--方式四：使用FactoryBean实例化bean--\u003e \u003cbean id=\"userDao\" class=\"com.itheima.factory.UserDaoFactoryBean\"/\u003e 使用之前的AppForInstanceUser测试类去运行看结果就行了。注意配置文件中id=“userDao\"是否重复。 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:4:3","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"五、Bean的生命周期【了解】 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:5:0","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"问题导入 问题1：多例的Bean能够配置并执行销毁的方法？ 问题2：如何做才执行Bean销毁的方法？ ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:5:1","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"1 生命周期相关概念介绍 生命周期：从创建到消亡的完整过程 bean生命周期：bean从创建到销毁的整体过程 bean生命周期控制：在bean创建后到销毁前做一些事情 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:5:2","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"2 代码演示 2.1 Bean生命周期控制 提供生命周期控制方法 public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } //表示bean初始化对应的操作 public void init(){ System.out.println(\"init...\"); } //表示bean销毁前对应的操作 public void destory(){ System.out.println(\"destory...\"); } } applicationContext.xml配置 \u003c!--init-method：设置bean初始化生命周期回调函数,此处填写init方法名--\u003e \u003c!--destroy-method：设置bean销毁生命周期回调函数，仅适用于单例对象，此处填写destory方法名--\u003e \u003cbean id=\"bookDao\" class=\"com.itheima.dao.impl.BookDaoImpl\" init-method=\"init\" destroy-method=\"destory\"/\u003e 测试类 public class AppForLifeCycle { public static void main( String[] args ) { //此处需要使用实现类类型，接口类型没有close方法 ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); bookDao.save(); //关闭容器，执行销毁的方法 ctx.close(); } } 2.2 Bean生命周期控制 实现InitializingBean, DisposableBean接口 public class BookServiceImpl implements BookService, InitializingBean, DisposableBean { private BookDao bookDao; public void setBookDao(BookDao bookDao) { System.out.println(\"set .....\"); this.bookDao = bookDao; } public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } public void destroy() throws Exception { System.out.println(\"service destroy\"); } public void afterPropertiesSet() throws Exception { System.out.println(\"service init\"); } } 测试类代码同《3.2.1 Bean生命周期控制》中的测试代码 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:5:3","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"3 Bean销毁时机 容器关闭前触发bean的销毁 关闭容器方式： 手工关闭容器 ConfigurableApplicationContext接口close()操作 注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机 ConfigurableApplicationContext接口registerShutdownHook()操作 public class AppForLifeCycle { public static void main( String[] args ) { //此处需要使用实现类类型，接口类型没有close方法 ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); bookDao.save(); //注册关闭钩子函数，在虚拟机退出之前回调此函数，关闭容器 ctx.registerShutdownHook(); //关闭容器 //ctx.close(); } } ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:5:4","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"六、依赖注入(DI配置) ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:6:0","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"1 依赖注入方式【重点】 问题导入 依赖注入有几种方式？ 1.1 依赖注入的两种方式 setter注入 简单类型 ==引用类型(很常用)== 构造器注入 简单类型 引用类型 1.2 setter方式注入 问题导入 setter方式注入使用什么子标签？ 引用类型 简单类型 1.3 构造方式注入 问题导入 构造方式注入使用什么子标签？ 引用类型 简单类型 参数适配【了解】 1.4 依赖注入方式选择 强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现 可选依赖使用setter注入进行，灵活性强 Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨 如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入 实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入 ==自己开发的模块推荐使用setter注入== ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:6:1","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"2 依赖自动装配【理解】 问题导入 如何配置按照类型自动装配？ 2.1 自动装配概念 IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配 自动装配方式 ==按类型（常用）== 按名称 按构造方法 不启用自动装配 2.2 自动装配类型 依赖自动装配 配置中使用bean标签autowire属性设置自动装配的类型 \u003cbean id=\"bookDao\" class=\"com.itheima.dao.impl.BookDaoImpl\"/\u003e \u003cbean id=\"bookService\" class=\"com.itheima.service.impl.BookServiceImpl\" autowire=\"byType\"/\u003e 依赖自动装配特征 自动装配用于引用类型依赖注入，不能对简单类型进行操作 使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用 使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用 自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:6:2","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"3 集合注入 3.1 注入数组类型数据 \u003cproperty name=\"array\"\u003e \u003carray\u003e \u003cvalue\u003e100\u003c/value\u003e \u003cvalue\u003e200\u003c/value\u003e \u003cvalue\u003e300\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e 3.2 注入List类型数据 \u003cproperty name=\"list\"\u003e \u003clist\u003e \u003cvalue\u003eitcast\u003c/value\u003e \u003cvalue\u003eitheima\u003c/value\u003e \u003cvalue\u003eboxuegu\u003c/value\u003e \u003cvalue\u003echuanzhihui\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e 3.3 注入Set类型数据 \u003cproperty name=\"set\"\u003e \u003cset\u003e \u003cvalue\u003eitcast\u003c/value\u003e \u003cvalue\u003eitheima\u003c/value\u003e \u003cvalue\u003eboxuegu\u003c/value\u003e \u003cvalue\u003eboxuegu\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e 3.4 注入Map类型数据 \u003cproperty name=\"map\"\u003e \u003cmap\u003e \u003centry key=\"country\" value=\"china\"/\u003e \u003centry key=\"province\" value=\"henan\"/\u003e \u003centry key=\"city\" value=\"kaifeng\"/\u003e \u003c/map\u003e \u003c/property\u003e 3.5 注入Properties类型数据 \u003cproperty name=\"properties\"\u003e \u003cprops\u003e \u003cprop key=\"country\"\u003echina\u003c/prop\u003e \u003cprop key=\"province\"\u003ehenan\u003c/prop\u003e \u003cprop key=\"city\"\u003ekaifeng\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e 说明：property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写\u003carray\u003e、\u003clist\u003e、\u003cset\u003e、\u003cmap\u003e、\u003cprops\u003e标签 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:6:3","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"今日目标 能够掌握注解开发定义Bean对象 能够掌握纯注解开发模式 能够配置注解开发依赖注入 能够配置注解开发管理第三方Bean 能够配置注解开发为第三方Bean注入资源 能够使用Spring整合Mybatis 能够使用Spring整合Junit ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:7:0","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"一、第三方资源配置管理 说明：以管理DataSource连接池对象为例讲解第三方资源配置管理 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:8:0","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"1 管理DataSource连接池对象 问题导入 配置数据库连接参数时，注入驱动类名是用driverClassName还是driver？ 1.1 管理Druid连接池【重点】 数据库准备 createdatabaseifnotexistsspring_dbcharactersetutf8;usespring_db;createtableifnotexiststbl_account(idintprimarykeyauto_increment,namevarchar(20),moneydouble);insertintotbl_accountvalues(null,'Tom',1000);insertintotbl_accountvalues(null,'Jerry',1000); 【第一步】添加Druid连接池依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid\u003c/artifactId\u003e \u003cversion\u003e1.1.16\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e 注意：除了添加以上两个依赖之外，别忘了添加spring-context依赖。 【第二步】配置DruidDataSource连接池Bean对象 \u003cbean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/spring_db\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"root\"/\u003e \u003c/bean\u003e 【第三步】在测试类中从IOC容器中获取连接池对象并打印 public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); DataSource dataSource = (DataSource) ctx.getBean(\"dataSource\"); System.out.println(dataSource); } } 1.2 管理c3p0连接池 【第一步】添加c3p0连接池依赖 \u003cdependency\u003e \u003cgroupId\u003ec3p0\u003c/groupId\u003e \u003cartifactId\u003ec3p0\u003c/artifactId\u003e \u003cversion\u003e0.9.1.2\u003c/version\u003e \u003c/dependency\u003e 【第二步】配置c3p0连接池Bean对象 \u003cbean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\u003e \u003cproperty name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/\u003e \u003cproperty name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/spring_db\"/\u003e \u003cproperty name=\"user\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"root\"/\u003e \u003cproperty name=\"maxPoolSize\" value=\"1000\"/\u003e \u003c/bean\u003e 注意：同一个Spring容器中不能有两个id=“dataSource\"的连接池。 【第三步】在测试类中从IOC容器中获取连接池对象并打印 public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); DataSource dataSource = (DataSource) ctx.getBean(\"dataSource\"); System.out.println(dataSource); } } ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:8:1","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"2 加载properties属性文件【重点】 目的：将数据库的连接参数抽取到一个单独的文件中，与Spring配置文件解耦。 问题导入 问题1：如何解决使用EL表达式读取属性文件中的值结果读取到了系统属性问题？ 问题2：加载properties文件写法标准写法该怎么写？ 2.1 基本用法 【第一步】编写jdbc.properties属性文件 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db jdbc.username=root jdbc.password=root 【第二步】在applicationContext.xml中开启开启context命名空间，加载jdbc.properties属性文件 ==小技巧：如果同学们觉得上述复制粘贴方式不好改或者容易改错，其实idea是有提示功能的，注意不要选错就行了。有些版本的idea没有这个提示，那么就按照上面复制粘贴的方式改，改完之后可以做成live template模板，后期直接用。== \u003ccontext:property-placeholder location=\"jdbc.properties\"/\u003e 【第三步】在配置连接池Bean的地方使用EL表达式获取jdbc.properties属性文件中的值 \u003cbean class=\"com.alibaba.druid.pool.DruidDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"${jdbc.driver}\"/\u003e \u003cproperty name=\"url\" value=\"${jdbc.url}\"/\u003e \u003cproperty name=\"username\" value=\"${jdbc.username}\"/\u003e \u003cproperty name=\"password\" value=\"${jdbc.password}\"/\u003e \u003c/bean\u003e 配置完成之后，运行之前的获取Druid连接池代码，可以获取到连接池对象就表示配置成功。 2.2 配置不加载系统属性 问题 如果属性文件中配置的不是jdbc.username，而是username=root666，那么使用${username}获取到的不是root666，而是计算机的名称。 原因 系统属性的优先级比我们属性文件中的高，替换了我们的username=root666。 解决 解决1：换一个名称，例如不叫username，叫jdbc.username。 解决2：使用system-properties-mode=“NEVER\"属性表示不使用系统属性。 \u003ccontext:property-placeholder location=\"jdbc.properties\" system-properties-mode=\"NEVER\"/\u003e 2.3 加载properties文件写法 不加载系统属性 \u003ccontext:property-placeholder location=\"jdbc.properties\" system-properties-mode=\"NEVER\"/\u003e 加载多个properties文件 \u003ccontext:property-placeholder location=\"jdbc.properties,msg.properties\"/\u003e 加载所有properties文件 \u003ccontext:property-placeholder location=\"*.properties\"/\u003e 加载properties文件**==标准格式==** \u003ccontext:property-placeholder location=\"classpath:*.properties\"/\u003e 加载properties文件标准格式 \u003ccontext:property-placeholder location=\"classpath*:*.properties\"/\u003e ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:8:2","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"二、Spring容器 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:9:0","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"1 Spring核心容器介绍 问题导入 问题：按照Bean名称获取Bean有什么弊端，按照Bean类型获取Bean有什么弊端？ 1.1 创建容器 方式一：类路径加载配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); 方式二：文件路径加载配置文件 ApplicationContext ctx = new FileSystemXmlApplicationContext(\"D:\\\\applicationContext.xml\"); 加载多个配置文件 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"bean1.xml\", \"bean2.xml\"); 1.2 获取bean对象 方式一：使用bean名称获取 弊端：需要自己强制类型转换 BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); ==方式二：使用bean名称获取并指定类型== 弊端：推荐使用 BookDao bookDao = ctx.getBean(\"bookDao\", BookDao.class); 方式三：使用bean类型获取 弊端：如果IOC容器中同类型的Bean对象有多个，此处获取会报错 BookDao bookDao = ctx.getBean(BookDao.class); 1.3 容器类层次结构 1.4 BeanFactory 类路径加载配置文件 Resource resources = new ClassPathResource(\"applicationContext.xml\"); BeanFactory bf = new XmlBeanFactory(resources); BookDao bookDao = bf.getBean(\"bookDao\", BookDao.class); bookDao.save(); BeanFactory创建完毕后，所有的Bean均为延迟加载，也就是说我们调用getBean()方法获取Bean对象时才创建Bean对象并返回给我们 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:9:1","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"2 Spring核心容器总结 2.1 容器相关 BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载 ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载 ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能 ApplicationContext接口常用初始化类 ==ClassPathXmlApplicationContext(常用)== FileSystemXmlApplicationContext 2.2 bean相关 2.3 依赖注入相关 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:9:2","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"三、Spring注解开发 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:10:0","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"1 注解开发定义Bean对象【重点】 目的：xml配置Bean对象有些繁琐，使用注解简化Bean对象的定义 问题导入 问题1：使用什么标签进行Spring注解包扫描？ 问题2：@Component注解和@Controller、@Service、@Repository三个衍生注解有什么区别？ 1.1 基本使用 【第一步】在applicationContext.xml中开启Spring注解包扫描 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003c!--扫描com.itheima包及其子包下的类中注解--\u003e \u003ccontext:component-scan base-package=\"com.itheima\"/\u003e \u003c/beans\u003e 【第二步】在类上使用@Component注解定义Bean。 //@Component定义bean @Component(\"bookDao\") public class BookDaoImpl implements BookDao { public void save() { System.out.println(\"book dao save ...\"); } } @Component public class BookServiceImpl implements BookService { private BookDao bookDao; public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 补充说明：如果@Component注解没有使用参数指定Bean的名称，那么类名首字母小写就是Bean在IOC容器中的默认名称。例如：BookServiceImpl对象在IOC容器中的名称是bookServiceImpl。 【第三步】在测试类中获取Bean对象 public class AppForAnnotation { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); System.out.println(bookDao); //按类型获取bean BookService bookService = ctx.getBean(BookService.class); System.out.println(bookService); } } 注意：在测试类中不要调用bookService的save方法，因为还没有给BookServiceImpl中的bookDao赋值，调用bookService的save方法会出现空指针异常。 运行结果 1.2 @Component三个衍生注解 说明：加粗的注解为常用注解 Spring提供**@Component**注解的三个衍生注解 @Controller：用于表现层bean定义 @Service：用于业务层bean定义 @Repository：用于数据层bean定义 @Repository(\"bookDao\") public class BookDaoImpl implements BookDao { } @Service public class BookServiceImpl implements BookService { } ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:10:1","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"2 纯注解开发模式【重点】 问题导入 问题1：配置类上使用什么注解表示该类是一个配置类？ 问题2：配置类上使用什么注解进行Spring注解包扫描？ 2.1 纯注解开发模式介绍 Spring3.0开启了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发赛道 Java类代替Spring核心配置文件 @Configuration注解用于设定当前类为配置类 @ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式 @ComponentScan({com.itheima.service\",\"com.itheima.dao\"}) 读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象 //加载配置文件初始化容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //加载配置类初始化容器 ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); 2.2 代码演示 【第一步】定义配置类代替配置文件 //声明当前类为Spring配置类 @Configuration //Spring注解扫描，相当于\u003ccontext:component-scan base-package=\"com.itheima\"/\u003e @ComponentScan(\"com.itheima\") //设置bean扫描路径，多个路径书写为字符串数组格式 //@ComponentScan({\"com.itheima.service\",\"com.itheima.dao\"}) public class SpringConfig { } 【第二步】在测试类中加载配置类，获取Bean对象并使用 public class AppForAnnotation { public static void main(String[] args) { //AnnotationConfigApplicationContext加载Spring配置类初始化Spring容器 ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\"); System.out.println(bookDao); //按类型获取bean BookService bookService = ctx.getBean(BookService.class); System.out.println(bookService); } } ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:10:2","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"3 注解开发Bean作用范围和生命周期管理 问题导入 在类上使用什么注解定义Bean的作用范围？ 3.1 bean作用范围注解配置 使用@Scope定义bean作用范围 @Repository @Scope(\"singleton\") public class BookDaoImpl implements BookDao { } 3.2 bean生命周期注解配置 使用@PostConstruct、@PreDestroy定义bean生命周期 @Repository @Scope(\"singleton\") public class BookDaoImpl implements BookDao { public BookDaoImpl() { System.out.println(\"book dao constructor ...\"); } @PostConstruct public void init(){ System.out.println(\"book init ...\"); } @PreDestroy public void destroy(){ System.out.println(\"book destory ...\"); } } ==注意：@PostConstruct和@PreDestroy注解是jdk中提供的注解，从jdk9开始，jdk中的javax.annotation包被移除了，也就是说这两个注解就用不了了，可以额外导入一下依赖解决这个问题。== \u003cdependency\u003e \u003cgroupId\u003ejavax.annotation\u003c/groupId\u003e \u003cartifactId\u003ejavax.annotation-api\u003c/artifactId\u003e \u003cversion\u003e1.3.2\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:10:3","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"4 注解开发依赖注入【重点】 问题导入 问题1：请描述@Autowired注解是如何进行自动装配的？ 问题2：请描述@Qualifier注解的作用 4.1 使用@Autowired注解开启自动装配模式（按类型） @Service public class BookServiceImpl implements BookService { //@Autowired：注入引用类型，自动装配模式，默认按类型装配 @Autowired private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } 说明：不管是使用配置文件还是配置类，都必须进行对应的Spring注解包扫描才可以使用。@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean有多个，那么默认按照变量名和Bean的名称匹配，建议使用@Qualifier注解指定要装配的bean名称 ==注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供setter方法。== 4.2 使用@Qualifier注解指定要装配的bean名称 目的：解决IOC容器中同类型Bean有多个装配哪一个的问题 @Service public class BookServiceImpl implements BookService { //@Autowired：注入引用类型，自动装配模式，默认按类型装配 @Autowired //@Qualifier：自动装配bean时按bean名称装配 @Qualifier(\"bookDao\") private BookDao bookDao; public void save() { System.out.println(\"book service save ...\"); bookDao.save(); } } ==注意：@Qualifier注解无法单独使用，必须配合@Autowired注解使用== 4.3 使用@Value实现简单类型注入 @Repository(\"bookDao\") public class BookDaoImpl implements BookDao { //@Value：注入简单类型（无需提供set方法） @Value(\"${name}\") private String name; public void save() { System.out.println(\"book dao save ...\" + name); } } 以上@Value注解中使用${name}从属性文件中读取name值，那么就需要在配置类或者配置文件中加载属性文件。 @Configuration @ComponentScan(\"com.itheima\") //@PropertySource加载properties配置文件 @PropertySource({\"classpath:jdbc.properties\"}) //{}可以省略不写 public class SpringConfig { } ==注意：@PropertySource()中加载多文件请使用数组格式配置，不允许使用通配符*== ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:10:4","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"5 注解开发管理第三方Bean【重点】 问题导入 导入自己定义的配置类有几种方式？ 【第一步】单独定义配置类 public class JdbcConfig { //@Bean：表示当前方法的返回值是一个bean对象，添加到IOC容器中 @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(\"com.mysql.jdbc.Driver\"); ds.setUrl(\"jdbc:mysql://localhost:3306/spring_db\"); ds.setUsername(\"root\"); ds.setPassword(\"root\"); return ds; } } 【第二步】将独立的配置类加入核心配置 方式1：@Import注解导入式 @Configuration @ComponentScan(\"com.itheima\") //@Import:导入配置信息 @Import({JdbcConfig.class}) public class SpringConfig { } 方式2：@ComponentScan扫描式 @Configuration @ComponentScan({\"com.itheima.config\",\"com.itheima.service\",\"com.itheima.dao\"}) //只要com.itheima.config包扫到了就行，三个包可以合并写成com.itheima public class SpringConfig { } ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:10:5","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"6 注解开发为第三方Bean注入资源【重点】 问题导入 配置类中如何注入简单类型数据，如何注入引用类型数据？ 6.1 简单类型依赖注入 public class JdbcConfig { //1.定义一个方法获得要管理的对象 @Value(\"com.mysql.jdbc.Driver\") private String driver; @Value(\"jdbc:mysql://localhost:3306/spring_db\") private String url; @Value(\"root\") private String userName; @Value(\"root\") private String password; //2.@Bean：表示当前方法的返回值是一个bean对象，添加到IOC容器中 @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 说明：如果@Value()中使用了EL表达式读取properties属性文件中的内容，那么就需要加载properties属性文件。 6.2 引用类型依赖注入 //Spring会自动从IOC容器中找到BookDao对象赋值给参数bookDao变量，如果没有就会报错。 @Bean public DataSource dataSource(BookDao bookDao){ System.out.println(bookDao); DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } 说明：引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:10:6","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"7 注解开发总结 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:10:7","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"四、Spring整合其他技术【重点】 ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:11:0","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"1 Spring整合mybatis【重点】 1.1 思路分析 问题导入 mybatis进行数据层操作的核心对象是谁？ 1.1.1 MyBatis程序核心对象分析 1.1.2 整合MyBatis 使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息 使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中 1.2 代码实现 问题导入 问题1：Spring整合mybatis的依赖叫什么？ 问题2：Spring整合mybatis需要管理配置哪两个Bean，这两个Bean作用分别是什么？ 【前置工作】 在pom.xml中添加spring-context、druid、mybatis、mysql-connector-java等基础依赖。 准备service和dao层基础代码 public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List\u003cAccount\u003e findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List\u003cAccount\u003e findAll() { return accountDao.findAll(); } } public interface AccountDao { @Insert(\"insert into tbl_account(name,money)values(#{name},#{money})\") void save(Account account); @Delete(\"delete from tbl_account where id = #{id} \") void delete(Integer id); @Update(\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \") void update(Account account); @Select(\"select * from tbl_account\") List\u003cAccount\u003e findAll(); @Select(\"select * from tbl_account where id = #{id} \") Account findById(Integer id); } 【第一步】导入Spring整合Mybatis依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.10.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e1.3.0\u003c/version\u003e \u003c/dependency\u003e 【第二步】创建JdbcConfig配置DataSource数据源 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root public class JdbcConfig { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String userName; @Value(\"${jdbc.password}\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } 【第三步】创建MybatisConfig整合mybatis public class MybatisConfig { //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\"com.itheima.domain\"); ssfb.setDataSource(dataSource); return ssfb; } //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\"com.itheima.dao\"); return msc; } } 【第四步】创建SpringConfig主配置类进行包扫描和加载其他配置类 @Configuration @ComponentScan(\"com.itheima\") //@PropertySource：加载类路径jdbc.properties文件 @PropertySource(\"classpath:jdbc.properties\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } 【第五步】定义测试类进行测试 public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); } } ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:11:1","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"2 Spring整合Junit单元测试【重点】 问题导入 Spring整合Junit的两个注解作用分别是什么？ 【第一步】导入整合的依赖坐标spring-test \u003c!--junit--\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e \u003c!--spring整合junit--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-test\u003c/artifactId\u003e \u003cversion\u003e5.1.9.RELEASE\u003c/version\u003e \u003c/dependency\u003e 【第二步】使用Spring整合Junit专用的类加载器 【第三步】加载配置文件或者配置类 //【第二步】使用Spring整合Junit专用的类加载器 @RunWith(SpringJUnit4ClassRunner.class) //【第三步】加载配置文件或者配置类 @ContextConfiguration(classes = {SpringConfiguration.class}) //加载配置类 //@ContextConfiguration(locations={\"classpath:applicationContext.xml\"})//加载配置文件 public class AccountServiceTest { //支持自动装配注入bean @Autowired private AccountService accountService; @Test public void testFindById(){ System.out.println(accountService.findById(1)); } @Test public void testFindAll(){ System.out.println(accountService.findAll()); } } ==注意：junit的依赖至少要是4.12版本,可以是4.13等版本,否则出现如下异常：== ","date":"2022-09-06","objectID":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/:11:2","tags":null,"title":"Spring第一天","uri":"/spring%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"categories":null,"content":"MySQL ","date":"2021-11-06","objectID":"/mysql/:0:0","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"MySQL安装 安装包 到官网下载安装包 设置环境变量 新建配置文件 新建my.ini文件,如下 [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] # 设置3306端口 port=3306 # 设置mysql的安装目录(mysql 8.0 中用的是双斜线) basedir=D:\\\\Enviroment\\\\mysql-8.0.28-winx64 # 设置mysql数据库的数据的存放目录 datadir=D:\\\\Enviroment\\\\mysql-8.0.28-winx64\\\\data # 允许最大连接数 max_connections=200 # 允许连接失败的次数。 max_connect_errors=10 # 服务端使用的字符集默认为utf8 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # sql新版本与旧版本navicat的兼容[mysqld] sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION' 初始化MySQL 在管理员权限下,在命令行中输入 mysqld --initialize-insecure 注册MySQL服务 命令行输入 mysqld -install 启动MySQL服务 命令行输入 net start mysql // 启动mysql服务 net stop mysql // 停止mysql服务 修改账户密码 键入 mysql -u root -p //登录账户 登录账户,然后输入要设置的密码 直接登录: mysql -uroot -p密码 登录参数: mysql -u用户名 -p密码 -h要连接的mysql服务器的ip地址(默认127.0.0.1) -P端口号(默认3306) 退出 exit quit ","date":"2021-11-06","objectID":"/mysql/:1:0","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"数据库操作 ","date":"2021-11-06","objectID":"/mysql/:2:0","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"命令行操作数据库 创建数据库 : create database [if not exists] 数据库名; 删除数据库 : drop database [if exists] 数据库名; 查看数据库 : show databases; 使用数据库 : use 数据库名; 查看当前使用的数据库：select database(); ","date":"2021-11-06","objectID":"/mysql/:2:1","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"DDL（数据定义语言） ","date":"2021-11-06","objectID":"/mysql/:3:0","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"查询表 查询当前数据库下所有表的名称：show tables； 查询表结构：desc 表名称； ","date":"2021-11-06","objectID":"/mysql/:3:1","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"创建表 createtable[ifnotexists]表名(字段名1列类型[属性][索引][注释],字段名2列类型[属性][索引][注释],#...字段名n列类型[属性][索引][注释]#最后一行不用加逗号)[表类型][表字符集][注释]; ","date":"2021-11-06","objectID":"/mysql/:3:2","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"修改表 修改表名 : ALTER TABLE 表名 RENAME TO 新表名 添加字段 : ALTER TABLE 表名 ADD 列名 列属性[属性] 修改字段 : ALTER TABLE 表名 MODIFY 列名 新类型[属性] ALTER TABLE 表名 CHANGE 旧列名 新列名 新属性[属性] 删除字段 : ALTER TABLE 表名 DROP 列名 ","date":"2021-11-06","objectID":"/mysql/:3:3","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"删除表 语法： DROP TABLE [IF EXISTS] 表名 IF EXISTS 为可选 , 判断是否存在该数据表 如删除不存在的数据表会抛出错误 ","date":"2021-11-06","objectID":"/mysql/:3:4","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"DML（数据操作语言） ","date":"2021-11-06","objectID":"/mysql/:4:0","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"添加数据 给指定列添加数据 INSERTINTO表名(列名1,列名2,…)1VALUES(值1,值2,…); 给全部列添加数据 INSERTINTO表名VALUES(值1,值2,…); 批量添加数据 INSERTINTO表名(列名1,列名2,…)VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;INSERTINTO表名VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…; ","date":"2021-11-06","objectID":"/mysql/:4:1","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"修改数据 修改表数据: UPDATE表名SET列名1=值1,列1名2=值2,…[WHERE条件]; 注意： 修改语句中如果不加条件，则将所有数据都修改！ 像上面的语句中的中括号，表示在写sql语句中可以省略这部分 ","date":"2021-11-06","objectID":"/mysql/:4:2","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"删除数据 删除数据: DELETEFROM表名[WHERE条件]; ","date":"2021-11-06","objectID":"/mysql/:4:3","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"DQL(数据查询语言) ","date":"2021-11-06","objectID":"/mysql/:5:0","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"基础查询 查询多个字段 SELECT字段列表FROM表名;SELECT*FROM表名;-- 查询所有数据 去除重复记录 SELECTDISTINCT1字段列表FROM表名; ​ 起别名 1AS:AS也可以省略 ","date":"2021-11-06","objectID":"/mysql/:5:1","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"条件查询 语法: SELECT字段列表FROM表名WHERE条件列表; 条件: ","date":"2021-11-06","objectID":"/mysql/:5:2","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"模糊查询 模糊查询使用like关键字，可以使用通配符进行占位: （1）_ : 代表单个任意字符 （2）% : 代表任意个数字符 eg: 查询姓’马’的学员信息 select*fromstuwherenamelike'马%'; 查询第二个字是’花’的学员信息 select*fromstuwherenamelike'_花%'; 查询包含’德’的学员信息 select*fromstuwherenamelike'%德%'; ","date":"2021-11-06","objectID":"/mysql/:5:3","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"排序查询 语法: SELECT字段列表FROM表名ORDERBY排序字段名1[排序方式1],排序字段名2[排序方式2]…; 语句排序方式有两种: ASC ： 升序排列 （默认值） DESC ： 降序排列 注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序 eg: 查询学生信息,按照数学降序,如果数学成绩一样,按照英语升序排列 select*fromstuorderbymathdesc,englishasc; ","date":"2021-11-06","objectID":"/mysql/:5:4","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"聚合函数 概念 将一列数据作为一个整体,进行纵向计算 一需求让我们求表中所有数据的数学成绩的总和. 分类 函数名 功能 count(列名) 统计数量(一般选用不为null的列)列名 max(列名) 最大值 min(列名) 最小值 sum(列名) 求和 avg(列名) 平均值 语法 SELECT聚合函数名(列名)FROM表; 注意：null 值不参与所有聚合函数运算 ","date":"2021-11-06","objectID":"/mysql/:5:5","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"分组查询 语法 SELECT字段列表FROM表名[WHERE分组前条件限定]GROUPBY分组字段名[HAVING分组后条件过滤]; 注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义 where 和 having 区别： 执行时机不一样：where 是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。 可判断的条件不一样：where 不能对聚合函数进行判断，having 可以。 ","date":"2021-11-06","objectID":"/mysql/:5:6","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"分页查询 下图所示，大家在很多网站都见过类似的效果，如京东、百度、淘宝等。分页查询是将数据一页一页的展示给用户看，用 户也可以通过点击查看下一页的数据。 语法 SELECT字段列表FROM表名LIMIT起始索引,查询条目数; 注意： 上述语句中的起始索引是从0开始 起始索引 = (当前页码 - 1) * 每页显示的条数 MySQL高级 ","date":"2021-11-06","objectID":"/mysql/:5:7","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"1.约束 上面表中可以看到表中数据存在一些问题： id 列一般是用标示数据的唯一性的，而上述表中的id为1的有三条数据，并且 马花疼 没有id进行标示 柳白 这条数据的age列的数据是3000，而人也不可能活到3000岁 马运 这条数据的math数学成绩是-5，而数学学得再不好也不可能出现负分 柳青 这条数据的english列（英文成绩）值为null，而成绩即使没考也得是0分 针对上述数据问题，我们就可以从数据库层面在添加数据的时候进行限制，这个就是约束。 ","date":"2021-11-06","objectID":"/mysql/:6:0","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"1.1 概念 约束是作用于表中列上的规则，用于限制加入表的数据 例如：我们可以给id列加约束，让其值不能重复，不能为null值。 约束的存在保证了数据库中数据的正确性、有效性和完整性 添加约束可以在添加数据的时候就限制不正确的数据，年龄是3000，数学成绩是-5分这样无效的数据，继而保障数据的完整性。 ","date":"2021-11-06","objectID":"/mysql/:6:1","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"1.2 分类 非空约束： 关键字是 NOT NULL 保证列中所有的数据不能有null值。 例如：id列在添加 马花疼 这条数据时就不能添加成功。 唯一约束：关键字是 UNIQUE 保证列中所有数据各不相同。 例如：id列中三条数据的值都是1，这样的数据在添加时是绝对不允许的。 主键约束： 关键字是 PRIMARY KEY 主键是一行数据的唯一标识，要求非空且唯一。一般我们都会给没张表添加一个主键列用来唯一标识数据。 例如：上图表中id就可以作为主键，来标识每条数据。那么这样就要求数据中id的值不能重复，不能为null值。 检查约束： 关键字是 CHECK 保证列中的值满足某一条件。 例如：我们可以给age列添加一个范围，最低年龄可以设置为1，最大年龄就可以设置为300，这样的数据才更合理些。 注意：MySQL不支持检查约束。 这样是不是就没办法保证年龄在指定的范围内了？从数据库层面不能保证，以后可以在java代码中进行限制，一样也可以实现要求。 默认约束： 关键字是 DEFAULT 保存数据时，未指定值则采用默认值。 例如：我们在给english列添加该约束，指定默认值是0，这样在添加数据时没有指定具体值时就会采用默认给定的0。 外键约束： 关键字是 FOREIGN KEY 外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。 外键约束现在可能还不太好理解，后面我们会重点进行讲解。 ","date":"2021-11-06","objectID":"/mysql/:6:2","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"1.3 非空约束 概念 非空约束用于保证列中所有数据不能有NULL值 语法 添加约束 -- 创建表时添加非空约束 CREATETABLE表名(列名数据类型NOTNULL,…); -- 建完表后添加非空约束 ALTERTABLE表名MODIFY字段名数据类型NOTNULL; 删除约束 ALTERTABLE表名MODIFY字段名数据类型; ","date":"2021-11-06","objectID":"/mysql/:6:3","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"1.4 唯一约束 概念 唯一约束用于保证列中所有数据各不相同 语法 添加约束 -- 创建表时添加唯一约束 CREATETABLE表名(列名数据类型UNIQUE[AUTO_INCREMENT],-- AUTO_INCREMENT: 当不指定值时自动增长 …);CREATETABLE表名(列名数据类型,…[CONSTRAINT][约束名称]UNIQUE(列名)); -- 建完表后添加唯一约束 ALTERTABLE表名MODIFY字段名数据类型UNIQUE; 删除约束 ALTERTABLE表名DROPINDEX字段名; ","date":"2021-11-06","objectID":"/mysql/:6:4","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"1.5 主键约束 概念 主键是一行数据的唯一标识，要求非空且唯一 一张表只能有一个主键 语法 添加约束 -- 创建表时添加主键约束 CREATETABLE表名(列名数据类型PRIMARYKEY[AUTO_INCREMENT],…);CREATETABLE表名(列名数据类型,[CONSTRAINT][约束名称]PRIMARYKEY(列名)); -- 建完表后添加主键约束 ALTERTABLE表名ADDPRIMARYKEY(字段名); 删除约束 ALTERTABLE表名DROPPRIMARYKEY; ","date":"2021-11-06","objectID":"/mysql/:6:5","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"1.6 默认约束 概念 保存数据时，未指定值则采用默认值 语法 添加约束 -- 创建表时添加默认约束 CREATETABLE表名(列名数据类型DEFAULT默认值,…); -- 建完表后添加默认约束 ALTERTABLE表名ALTER列名SETDEFAULT默认值; 删除约束 ALTERTABLE表名ALTER列名DROPDEFAULT; ","date":"2021-11-06","objectID":"/mysql/:6:6","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"1.7 约束练习 根据需求，为表添加合适的约束 -- 员工表 CREATETABLEemp(idINT,-- 员工id，主键且自增长 enameVARCHAR(50),-- 员工姓名，非空且唯一 joindateDATE,-- 入职日期，非空 salaryDOUBLE(7,2),-- 工资，非空 bonusDOUBLE(7,2)-- 奖金，如果没有将近默认为0 ); 上面一定给出了具体的要求，我们可以根据要求创建这张表，并为每一列添加对应的约束。建表语句如下： DROPTABLEIFEXISTSemp;-- 员工表 CREATETABLEemp(idINTPRIMARYKEY,-- 员工id，主键且自增长 enameVARCHAR(50)NOTNULLUNIQUE,-- 员工姓名，非空并且唯一 joindateDATENOTNULL,-- 入职日期，非空 salaryDOUBLE(7,2)NOTNULL,-- 工资，非空 bonusDOUBLE(7,2)DEFAULT0-- 奖金，如果没有奖金默认为0 ); 通过上面语句可以创建带有约束的 emp 表，约束能不能发挥作用呢。接下来我们一一进行验证，先添加一条没有问题的数据 INSERTINTOemp(id,ename,joindate,salary,bonus)values(1,'张三','1999-11-11',8800,5000); 验证主键约束，非空且唯一 INSERTINTOemp(id,ename,joindate,salary,bonus)values(null,'张三','1999-11-11',8800,5000); 执行结果如下： 从上面的结果可以看到，字段 id 不能为null。那我们重新添加一条数据，如下： INSERTINTOemp(id,ename,joindate,salary,bonus)values(1,'张三','1999-11-11',8800,5000); 执行结果如下： 从上面结果可以看到，1这个值重复了。所以主键约束是用来限制数据非空且唯一的。那我们再添加一条符合要求的数据 INSERTINTOemp(id,ename,joindate,salary,bonus)values(2,'李四','1999-11-11',8800,5000); 执行结果如下： 验证非空约束 INSERTINTOemp(id,ename,joindate,salary,bonus)values(3,null,'1999-11-11',8800,5000); 执行结果如下： 从上面结果可以看到，ename 字段的非空约束生效了。 验证唯一约束 INSERTINTOemp(id,ename,joindate,salary,bonus)values(3,'李四','1999-11-11',8800,5000); 执行结果如下： 从上面结果可以看到，ename 字段的唯一约束生效了。 验证默认约束 INSERTINTOemp(id,ename,joindate,salary)values(3,'王五','1999-11-11',8800); 执行完上面语句后查询表中数据，如下图可以看到王五这条数据的bonus列就有了默认值0。 ==注意：默认约束只有在不给值时才会采用默认值。如果给了null，那值就是null值。== 如下： INSERTINTOemp(id,ename,joindate,salary,bonus)values(4,'赵六','1999-11-11',8800,null); 执行完上面语句后查询表中数据，如下图可以看到赵六这条数据的bonus列的值是null。 验证自动增长： auto_increment 当列是数字类型 并且唯一约束 重新创建 emp 表，并给id列添加自动增长 -- 员工表 CREATETABLEemp(idINTPRIMARYKEYauto_increment,-- 员工id，主键且自增长 enameVARCHAR(50)NOTNULLUNIQUE,-- 员工姓名，非空并且唯一 joindateDATENOTNULL,-- 入职日期，非空 salaryDOUBLE(7,2)NOTNULL,-- 工资，非空 bonusDOUBLE(7,2)DEFAULT0-- 奖金，如果没有奖金默认为0 ); 接下来给emp添加数据，分别验证不给id列添加值以及给id列添加null值，id列的值会不会自动增长： INSERTINTOemp(ename,joindate,salary,bonus)values('赵六','1999-11-11',8800,null);INSERTINTOemp(id,ename,joindate,salary,bonus)values(null,'赵六2','1999-11-11',8800,null);INSERTINTOemp(id,ename,joindate,salary,bonus)values(null,'赵六3','1999-11-11',8800,null); ","date":"2021-11-06","objectID":"/mysql/:6:7","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"1.8 外键约束 1.8.1 概述 外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。 如何理解上面的概念呢？如下图有两张表，员工表和部门表： 员工表中的dep_id字段是部门表的id字段关联，也就是说1号学生张三属于1号部门研发部的员工。现在我要删除1号部门，就会出现错误的数据（员工表中属于1号部门的数据）。而我们上面说的两张表的关系只是我们认为它们有关系，此时需要通过外键让这两张表产生数据库层面的关系，这样你要删除部门表中的1号部门的数据将无法删除。 1.8.2 语法 添加外键约束 -- 创建表时添加外键约束 CREATETABLE表名(列名数据类型,…[CONSTRAINT][外键名称]FOREIGNKEY(外键列名)REFERENCES主表(主表列名)); -- 建完表后添加外键约束 ALTERTABLE表名ADDCONSTRAINT外键名称FOREIGNKEY(外键字段名称)REFERENCES主表名称(主表列名称); 删除外键约束 ALTERTABLE表名DROPFOREIGNKEY外键名称; 1.8.3 练习 根据上述语法创建员工表和部门表，并添加上外键约束： -- 删除表 DROPTABLEIFEXISTSemp;DROPTABLEIFEXISTSdept;-- 部门表 CREATETABLEdept(idintprimarykeyauto_increment,dep_namevarchar(20),addrvarchar(20));-- 员工表 CREATETABLEemp(idintprimarykeyauto_increment,namevarchar(20),ageint,dep_idint,-- 添加外键 dep_id,关联 dept 表的id主键 CONSTRAINTfk_emp_deptFOREIGNKEY(dep_id)REFERENCESdept(id)); 添加数据 -- 添加 2 个部门 insertintodept(dep_name,addr)values('研发部','广州'),('销售部','深圳');-- 添加员工,dep_id 表示员工所在的部门 INSERTINTOemp(NAME,age,dep_id)VALUES('张三',20,1),('李四',20,1),('王五',20,1),('赵六',20,2),('孙七',22,2),('周八',18,2); 此时删除 研发部 这条数据，会发现无法删除。 删除外键 altertableempdropFOREIGNkeyfk_emp_dept; 重新添加外键 altertableempaddCONSTRAINTfk_emp_deptFOREIGNkey(dep_id)REFERENCESdept(id); ","date":"2021-11-06","objectID":"/mysql/:6:8","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"2.数据库设计 ","date":"2021-11-06","objectID":"/mysql/:7:0","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"2.1 数据库设计简介 软件的研发步骤 数据库设计概念 数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS，为这个业务系统构造出最优的数据存储模型。 建立数据库中的==表结构==以及==表与表之间的关联关系==的过程。 有哪些表？表里有哪些字段？表和表之间有什么关系？ 数据库设计的步骤 需求分析（数据是什么? 数据具有哪些属性? 数据与属性的特点是什么） 逻辑分析（通过ER图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统） 如下图就是ER(Entity/Relation)图： 物理设计（根据数据库自身的特点把逻辑设计转换为物理设计） 维护设计（1.对新的需求进行建表；2.表优化） 表关系 一对一 如：用户 和 用户详情 一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能 上图左边是用户的详细信息，而我们真正在展示用户信息时最长用的则是上图右边红框所示，所以我们会将详细信息查分成两周那个表。 一对多 如：部门 和 员工 一个部门对应多个员工，一个员工对应一个部门。如下图： 多对多 如：商品 和 订单 一个商品对应多个订单，一个订单包含多个商品。如下图： ","date":"2021-11-06","objectID":"/mysql/:7:1","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"2.2 表关系(一对多) 一对多 如：部门 和 员工 一个部门对应多个员工，一个员工对应一个部门。 实现方式 ==在多的一方建立外键，指向一的一方的主键== 案例 我们还是以 员工表 和 部门表 举例: 经过分析发现，员工表属于多的一方，而部门表属于一的一方，此时我们会在员工表中添加一列（dep_id），指向于部门表的主键（id）： 建表语句如下： -- 删除表 DROPTABLEIFEXISTStb_emp;DROPTABLEIFEXISTStb_dept;-- 部门表 CREATETABLEtb_dept(idintprimarykeyauto_increment,dep_namevarchar(20),addrvarchar(20));-- 员工表 CREATETABLEtb_emp(idintprimarykeyauto_increment,namevarchar(20),ageint,dep_idint,-- 添加外键 dep_id,关联 dept 表的id主键 CONSTRAINTfk_emp_deptFOREIGNKEY(dep_id)REFERENCEStb_dept(id)); 查看表结构模型图： ","date":"2021-11-06","objectID":"/mysql/:7:2","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"2.3 表关系(多对多) 多对多 如：商品 和 订单 一个商品对应多个订单，一个订单包含多个商品 实现方式 ==建立第三张中间表，中间表至少包含两个外键，分别关联两方主键== 案例 我们以 订单表 和 商品表 举例： 经过分析发现，订单表和商品表都属于多的一方，此时需要创建一个中间表，在中间表中添加订单表的外键和商品表的外键指向两张表的主键： 建表语句如下： -- 删除表 DROPTABLEIFEXISTStb_order_goods;DROPTABLEIFEXISTStb_order;DROPTABLEIFEXISTStb_goods;-- 订单表 CREATETABLEtb_order(idintprimarykeyauto_increment,paymentdouble(10,2),payment_typeTINYINT,statusTINYINT);-- 商品表 CREATETABLEtb_goods(idintprimarykeyauto_increment,titlevarchar(100),pricedouble(10,2));-- 订单商品中间表 CREATETABLEtb_order_goods(idintprimarykeyauto_increment,order_idint,goods_idint,countint);-- 建完表后，添加外键 altertabletb_order_goodsaddCONSTRAINTfk_order_idFOREIGNkey(order_id)REFERENCEStb_order(id);altertabletb_order_goodsaddCONSTRAINTfk_goods_idFOREIGNkey(goods_id)REFERENCEStb_goods(id); 查看表结构模型图： ","date":"2021-11-06","objectID":"/mysql/:7:3","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"2.4 表关系(一对一) 一对一 如：用户 和 用户详情 一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能 实现方式 ==在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)== 案例 我们以 用户表 举例： 而在真正使用过程中发现 id、photo、nickname、age、gender 字段比较常用，此时就可以将这张表查分成两张表。 ​ ​ ​ 建表语句如下： createtabletb_user_desc(idintprimarykeyauto_increment,cityvarchar(20),eduvarchar(10),incomeint,statuschar(2),desvarchar(100));createtabletb_user(idintprimarykeyauto_increment,photovarchar(100),nicknamevarchar(50),ageint,genderchar(1),desc_idintunique,-- 添加外键 CONSTRAINTfk_user_descFOREIGNKEY(desc_id)REFERENCEStb_user_desc(id)); ​ 查看表结构模型图： ","date":"2021-11-06","objectID":"/mysql/:7:4","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"2.5 数据库设计案例 根据下图设计表及表和表之间的关系： 经过分析，我们分为 专辑表 曲目表 短评表 用户表 4张表。 一个专辑可以有多个曲目，一个曲目只能属于某一张专辑，所以专辑表和曲目表的关系是==一对多==。 一个专辑可以被多个用户进行评论，一个用户可以对多个专辑进行评论，所以专辑表和用户表的关系是 ==多对多==。 一个用户可以发多个短评，一个短评只能是某一个人发的，所以用户表和短评表的关系是 ==一对多==。 ","date":"2021-11-06","objectID":"/mysql/:7:5","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"3.多表查询 多表查询顾名思义就是从多张表中一次性的查询出我们想要的数据。我们通过具体的sql给他们演示，先准备环境 DROPTABLEIFEXISTSemp;DROPTABLEIFEXISTSdept;#创建部门表CREATETABLEdept(didINTPRIMARYKEYAUTO_INCREMENT,dnameVARCHAR(20));#创建员工表CREATETABLEemp(idINTPRIMARYKEYAUTO_INCREMENT,NAMEVARCHAR(10),genderCHAR(1),-- 性别 salaryDOUBLE,-- 工资 join_dateDATE,-- 入职日期 dep_idINT,FOREIGNKEY(dep_id)REFERENCESdept(did)-- 外键，关联部门表(部门表的主键) );-- 添加部门数据 INSERTINTOdept(dNAME)VALUES('研发部'),('市场部'),('财务部'),('销售部');-- 添加员工数据 INSERTINTOemp(NAME,gender,salary,join_date,dep_id)VALUES('孙悟空','男',7200,'2013-02-24',1),('猪八戒','男',3600,'2010-12-02',2),('唐僧','男',9000,'2008-08-08',2),('白骨精','女',5000,'2015-10-07',3),('蜘蛛精','女',4500,'2011-03-14',1),('小白龙','男',2500,'2011-02-14',null); 执行下面的多表查询语句 select*fromemp,dept;-- 从emp和dept表中查询所有的字段数据 结果如下： 从上面的结果我们看到有一些无效的数据，如 孙悟空 这个员工属于1号部门，但也同时关联的2、3、4号部门。所以我们要通过限制员工表中的 dep_id 字段的值和部门表 did 字段的值相等来消除这些无效的数据， select*fromemp,deptwhereemp.dep_id=dept.did; 执行后结果如下： 上面语句就是连接查询，那么多表查询都有哪些呢？ 连接查询 内连接查询 ：相当于查询AB交集数据 外连接查询 左外连接查询 ：相当于查询A表所有数据和交集部门数据 右外连接查询 ： 相当于查询B表所有数据和交集部分数据 子查询 ","date":"2021-11-06","objectID":"/mysql/:8:0","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"3.1 内连接查询 语法 -- 隐式内连接 SELECT字段列表FROM表1,表2…WHERE条件;-- 显示内连接 SELECT字段列表FROM表1[INNER]JOIN表2ON条件; ==内连接相当于查询 A B 交集数据== 案例 隐式内连接 SELECT*FROMemp,deptWHEREemp.dep_id=dept.did; 执行上述语句结果如下： 查询 emp的 name， gender，dept表的dname SELECTemp.NAME,emp.gender,dept.dnameFROMemp,deptWHEREemp.dep_id=dept.did; 执行语句结果如下： 上面语句中使用表名指定字段所属有点麻烦，sql也支持给表指别名，上述语句可以改进为 SELECTt1.NAME,t1.gender,t2.dnameFROMempt1,deptt2WHEREt1.dep_id=t2.did; 显式内连接 select*fromempinnerjoindeptonemp.dep_id=dept.did;-- 上面语句中的inner可以省略，可以书写为如下语句 select*fromempjoindeptonemp.dep_id=dept.did; 执行结果如下： ","date":"2021-11-06","objectID":"/mysql/:8:1","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"3.2 外连接查询 语法 -- 左外连接 SELECT字段列表FROM表1LEFT[OUTER]JOIN表2ON条件;-- 右外连接 SELECT字段列表FROM表1RIGHT[OUTER]JOIN表2ON条件; 左外连接：相当于查询A表所有数据和交集部分数据 右外连接：相当于查询B表所有数据和交集部分数据 案例 查询emp表所有数据和对应的部门信息（左外连接） select*fromempleftjoindeptonemp.dep_id=dept.did; 执行语句结果如下： 结果显示查询到了左表（emp）中所有的数据及两张表能关联的数据。 查询dept表所有数据和对应的员工信息（右外连接） select*fromemprightjoindeptonemp.dep_id=dept.did; 执行语句结果如下： 结果显示查询到了右表（dept）中所有的数据及两张表能关联的数据。 要查询出部门表中所有的数据，也可以通过左外连接实现，只需要将两个表的位置进行互换： select*fromdeptleftjoinemponemp.dep_id=dept.did; ","date":"2021-11-06","objectID":"/mysql/:8:2","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"3.3 子查询 概念 ==查询中嵌套查询，称嵌套查询为子查询。== 什么是查询中嵌套查询呢？我们通过一个例子来看： 需求：查询工资高于猪八戒的员工信息。 来实现这个需求，我们就可以通过二步实现，第一步：先查询出来 猪八戒的工资 selectsalaryfromempwherename='猪八戒' 第二步：查询工资高于猪八戒的员工信息 select*fromempwheresalary\u003e3600; 第二步中的3600可以通过第一步的sql查询出来，所以将3600用第一步的sql语句进行替换 select*fromempwheresalary\u003e(selectsalaryfromempwherename='猪八戒'); 这就是查询语句中嵌套查询语句。 子查询根据查询结果不同，作用不同 子查询语句结果是单行单列，子查询语句作为条件值，使用 = != \u003e \u003c 等进行条件判断 子查询语句结果是多行单列，子查询语句作为条件值，使用 in 等关键字进行条件判断 子查询语句结果是多行多列，子查询语句作为虚拟表 案例 查询 ‘财务部’ 和 ‘市场部’ 所有的员工信息 -- 查询 '财务部' 或者 '市场部' 所有的员工的部门did selectdidfromdeptwheredname='财务部'ordname='市场部';select*fromempwheredep_idin(selectdidfromdeptwheredname='财务部'ordname='市场部'); 查询入职日期是 ‘2011-11-11’ 之后的员工信息和部门信息 -- 查询入职日期是 '2011-11-11' 之后的员工信息 select*fromempwherejoin_date\u003e'2011-11-11';-- 将上面语句的结果作为虚拟表和dept表进行内连接查询 select*from(select*fromempwherejoin_date\u003e'2011-11-11')t1,deptwheret1.dep_id=dept.did; ","date":"2021-11-06","objectID":"/mysql/:8:3","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"3.4 案例 环境准备： DROPTABLEIFEXISTSemp;DROPTABLEIFEXISTSdept;DROPTABLEIFEXISTSjob;DROPTABLEIFEXISTSsalarygrade;-- 部门表 CREATETABLEdept(didINTPRIMARYKEYPRIMARYKEY,-- 部门id dnameVARCHAR(50),-- 部门名称 locVARCHAR(50)-- 部门所在地 );-- 职务表，职务名称，职务描述 CREATETABLEjob(idINTPRIMARYKEY,jnameVARCHAR(20),descriptionVARCHAR(50));-- 员工表 CREATETABLEemp(idINTPRIMARYKEY,-- 员工id enameVARCHAR(50),-- 员工姓名 job_idINT,-- 职务id mgrINT,-- 上级领导 joindateDATE,-- 入职日期 salaryDECIMAL(7,2),-- 工资 bonusDECIMAL(7,2),-- 奖金 dept_idINT,-- 所在部门编号 CONSTRAINTemp_jobid_ref_job_id_fkFOREIGNKEY(job_id)REFERENCESjob(id),CONSTRAINTemp_deptid_ref_dept_id_fkFOREIGNKEY(dept_id)REFERENCESdept(id));-- 工资等级表 CREATETABLEsalarygrade(gradeINTPRIMARYKEY,-- 级别 losalaryINT,-- 最低工资 hisalaryINT-- 最高工资 );-- 添加4个部门 INSERTINTOdept(did,dname,loc)VALUES(10,'教研部','北京'),(20,'学工部','上海'),(30,'销售部','广州'),(40,'财务部','深圳');-- 添加4个职务 INSERTINTOjob(id,jname,description)VALUES(1,'董事长','管理整个公司，接单'),(2,'经理','管理部门员工'),(3,'销售员','向客人推销产品'),(4,'文员','使用办公软件');-- 添加员工 INSERTINTOemp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id)VALUES(1001,'孙悟空',4,1004,'2000-12-17','8000.00',NULL,20),(1002,'卢俊义',3,1006,'2001-02-20','16000.00','3000.00',30),(1003,'林冲',3,1006,'2001-02-22','12500.00','5000.00',30),(1004,'唐僧',2,1009,'2001-04-02','29750.00',NULL,20),(1005,'李逵',4,1006,'2001-09-28','12500.00','14000.00',30),(1006,'宋江',2,1009,'2001-05-01','28500.00',NULL,30),(1007,'刘备',2,1009,'2001-09-01','24500.00',NULL,10),(1008,'猪八戒',4,1004,'2007-04-19','30000.00',NULL,20),(1009,'罗贯中',1,NULL,'2001-11-17','50000.00',NULL,10),(1010,'吴用',3,1006,'2001-09-08','15000.00','0.00',30),(1011,'沙僧',4,1004,'2007-05-23','11000.00',NULL,20),(1012,'李逵',4,1006,'2001-12-03','9500.00',NULL,30),(1013,'小白龙',4,1004,'2001-12-03','30000.00',NULL,20),(1014,'关羽',4,1007,'2002-01-23','13000.00',NULL,10);-- 添加5个工资等级 INSERTINTOsalarygrade(grade,losalary,hisalary)VALUES(1,7000,12000),(2,12010,14000),(3,14010,20000),(4,20010,30000),(5,30010,99990); 需求 查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述 /* 分析： 1. 员工编号，员工姓名，工资 信息在emp 员工表中 2. 职务名称，职务描述 信息在 job 职务表中 3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id */-- 方式一 ：隐式内连接 SELECTemp.id,emp.ename,emp.salary,job.jname,job.descriptionFROMemp,jobWHEREemp.job_id=job.id;-- 方式二 ：显式内连接 SELECTemp.id,emp.ename,emp.salary,job.jname,job.descriptionFROMempINNERJOINjobONemp.job_id=job.id; 查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置 /* 分析： 1. 员工编号，员工姓名，工资 信息在emp 员工表中 2. 职务名称，职务描述 信息在 job 职务表中 3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id 4. 部门名称，部门位置 来自于 部门表 dept 5. dept 和 emp 一对多关系 dept.id = emp.dept_id */-- 方式一 ：隐式内连接 SELECTemp.id,emp.ename,emp.salary,job.jname,job.description,dept.dname,dept.locFROMemp,job,deptWHEREemp.job_id=job.idanddept.id=emp.dept_id;-- 方式二 ：显式内连接 SELECTemp.id,emp.ename,emp.salary,job.jname,job.description,dept.dname,dept.locFROMempINNERJOINjobONemp.job_id=job.idINNERJOINdeptONdept.id=emp.dept_id 查询员工姓名，工资，工资等级 /* 分析： 1. 员工姓名，工资 信息在emp 员工表中 2. 工资等级 信息在 salarygrade 工资等级表中 3. emp.salary \u003e= salarygrade.losalary and emp.salary \u003c= salarygrade.hisalary */SELECTemp.ename,emp.salary,t2.*FROMemp,salarygradet2WHEREemp.salary\u003e=t2.losalaryANDemp.salary\u003c=t2.hisalary 查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级 /* 分析： 1. 员工编号，员工姓名，工资 信息在emp 员工表中 2. 职务名称，职务描述 信息在 job 职务表中 3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id 4. 部门名称，部门位置 来自于 部门表 dept 5. dept 和 emp 一对多关系 dept.id = emp.dept_id 6. 工资等级 信息在 salarygrade 工资等级表中 7. emp.salary \u003e= salarygrade.losalary and emp.salary \u003c= salarygrade.hisalary */SELECTemp.id,emp.ename,emp.salary,job.jname,job.description,dept.dname,dept.loc,t2.gradeFROMempINNERJOINjobONemp.job_id=job.idINNERJOINdeptONdept.id=emp.dept_idINNERJOINsalarygradet2ONemp.salaryBETWEENt2.losalaryandt2.hisalary; 查询出部门编号、部门名称、部门位置、部门人数 /* 分析： 1. 部门编号、部门名称、部门位置 来自于部门 dept 表 2. 部门人数: 在emp表中 按照dept_id 进行分组，然后count(*)统计数量 3. 使用子查询，让部门表和分组后的表进行内连接 */-- 根据部门id分组查询每一个部门id和员工数 selectdept_id,count(*)fromempgroupbydept_id;SELECTdept.id,dept.dname,dept.loc,t1.countFROMdept,(SELECTdept_id,count(*)countFROMempGROUPBYdept_id)t1WHEREdept.id=t1.dept_id ","date":"2021-11-06","objectID":"/mysql/:8:4","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"UNION用法 联合查询 union 返回多个select语句的结果并合成一个结果集，结果集==去重== union all 返回多个select语句的结果并合成一个结果集，结果==不去重== ","date":"2021-11-06","objectID":"/mysql/:9:0","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"UNION 子句中使用 ORDER BY 子句中使用 ORDER BY，即将 SELECT 子句的结果先排序，然后再把这些子句查询的结果进行集合。 在子句中使用 ORDER BY，由于优先级问题，需要将整个子句加圆括号()，且必须与 LIMIT 结合使用： (SELECTaid,titleFROMarticleORDERBYaidDESCLIMIT10)UNIONALL(SELECTbid,titleFROMblogORDERBYbidDESCLIMIT10) ","date":"2021-11-06","objectID":"/mysql/:9:1","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"UNION 整句中使用 ORDER BY 如果想使用 ORDER BY 或 LIMIT 来对全部 UNION 结果进行分类或限制，则应对单个 SELECT 语句加圆括号，并把 ORDER BY 或 LIMIT 放到最后一个的后面。 (SELECT aid,title FROM article) UNION ALL (SELECT bid,title FROM blog) ORDER BY aid DESC ","date":"2021-11-06","objectID":"/mysql/:9:2","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"UNION ORDER BY 应用于别名 如果 SELECT 中使用到了字段别名，则 OEDER BY 必须引用别名： (SELECT a AS b FROM table) UNION (SELECT ...) ORDER BY b ","date":"2021-11-06","objectID":"/mysql/:9:3","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"MySQL UNION LIMIT 在 MySQL UNION 中使用 LIMIT 用于限制返回的记录条数，如果对 SELECT 子句做限制，需要对 SELECT 添加圆括号： (SELECT aid,title FROM article LIMIT 2) UNION ALL (SELECT bid,title FROM blog LIMIT 2) 该 SQL 会返回个 SELECT 语句的两条记录，如果不添加圆括号，则最后一个 LIMIT 2 会作用于整个 UNION 语句而一共返回 2 条记录。 同 ORDER BY 类似，当需要对整个 UNION 的结果进行 LIMIT 限制时，建议将各个 SELECT 语句用圆括号括起来以使语句更加清晰： (SELECT aid,title FROM article) UNION ALL (SELECT bid,title FROM blog) LIMIT 2 可见，LIMIT 与 ORDER BY 经常搭配使用，二者在 UNION 中的使用方式也是一致的。 ","date":"2021-11-06","objectID":"/mysql/:9:4","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"4.事务 ","date":"2021-11-06","objectID":"/mysql/:10:0","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"4.1 概述 数据库的事务（Transaction）是一种机制、一个操作序列，包含了==一组数据库操作命令==。 事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令==要么同时成功，要么同时失败==。 事务是一个不可分割的工作逻辑单元。 这些概念不好理解，接下来举例说明，如下图有一张表 张三和李四账户中各有100块钱，现李四需要转换500块钱给张三，具体的转账操作为 第一步：查询李四账户余额 第二步：从李四账户金额 -500 第三步：给张三账户金额 +500 现在假设在转账过程中第二步完成后出现了异常第三步没有执行，就会造成李四账户金额少了500，而张三金额并没有多500；这样的系统是有问题的。如果解决呢？使用事务可以解决上述问题 从上图可以看到在转账前开启事务，如果出现了异常回滚事务，三步正常执行就提交事务，这样就可以完美解决问题。 ","date":"2021-11-06","objectID":"/mysql/:10:1","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"4.2 语法 开启事务 STARTTRANSACTION;或者BEGIN; 提交事务 commit; 回滚事务 rollback; ","date":"2021-11-06","objectID":"/mysql/:10:2","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"4.3 代码验证 环境准备 DROPTABLEIFEXISTSaccount;-- 创建账户表 CREATETABLEaccount(idintPRIMARYKEYauto_increment,namevarchar(10),moneydouble(10,2));-- 添加数据 INSERTINTOaccount(name,money)values('张三',1000),('李四',1000); 不加事务演示问题 -- 转账操作 -- 1. 查询李四账户金额是否大于500 -- 2. 李四账户 -500 UPDATEaccountsetmoney=money-500wherename='李四';出现异常了...-- 此处不是注释，在整体执行时会出问题，后面的sql则不执行 -- 3. 张三账户 +500 UPDATEaccountsetmoney=money+500wherename='张三'; 整体执行结果肯定会出问题，我们查询账户表中数据，发现李四账户少了500。 添加事务sql如下： -- 开启事务 BEGIN;-- 转账操作 -- 1. 查询李四账户金额是否大于500 -- 2. 李四账户 -500 UPDATEaccountsetmoney=money-500wherename='李四';出现异常了...-- 此处不是注释，在整体执行时会出问题，后面的sql则不执行 -- 3. 张三账户 +500 UPDATEaccountsetmoney=money+500wherename='张三';-- 提交事务 COMMIT;-- 回滚事务 ROLLBACK; 上面sql中的执行成功进选择执行提交事务，而出现问题则执行回滚事务的语句。以后我们肯定不可能这样操作，而是在java中进行操作，在java中可以抓取异常，没出现异常提交事务，出现异常回滚事务。 ","date":"2021-11-06","objectID":"/mysql/:10:3","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"4.4 事务的四大特征 原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败 一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态 隔离性（Isolation） :多个事务之间，操作的可见性 持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 ==说明：== mysql中事务是自动提交的。 也就是说我们不添加事务执行sql语句，语句执行完毕会自动的提交事务。 可以通过下面语句查询默认提交方式： SELECT @@autocommit; 查询到的结果是1 则表示自动提交，结果是0表示手动提交。当然也可以通过下面语句修改提交方式 set@@autocommit=0; ","date":"2021-11-06","objectID":"/mysql/:10:4","tags":null,"title":"MySql","uri":"/mysql/"},{"categories":null,"content":"Git ","date":"2021-09-06","objectID":"/git/:0:0","tags":null,"title":"Git","uri":"/git/"},{"categories":null,"content":"git bash 命令 基本Linux命令行使用 1）、cd : 改变目录。 2）、cd . . 回退到上一个目录，直接cd进入默认目录 3）、pwd : 显示当前所在的目录路径。 4）、ls(ll): 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。 5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。 6）、rm: 删除一个文件, rm index.js 就会把index.js文件删除。 7）、mkdir: 新建一个目录,就是新建一个文件夹。 8）、rm -r : 删除一个文件夹, rm -r src 删除src目录 9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写, 必须保证文件和目标文件夹在同一目录下。 10）、reset 重新初始化终端/清屏。 11）、clear 清屏。 12）、history 查看命令历史。 13）、help 帮助。 14）、exit 退出。 15）、#表示注释 ","date":"2021-09-06","objectID":"/git/:1:0","tags":null,"title":"Git","uri":"/git/"},{"categories":null,"content":"Git 配置 查看配置 git config -l # 查看系统config git config --system --list # 查看当前用户（global）配置 git config --global --list *# 设置用户名与邮箱（用户标识，必要） git config --global user.name \"用户名称\" #名称 git config --global user.email 888888@qq.com #邮箱 ","date":"2021-09-06","objectID":"/git/:2:0","tags":null,"title":"Git","uri":"/git/"},{"categories":null,"content":"Git理论 Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下： Workspace：工作区，就是平时存放项目代码的地方 Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 git的工作流程一般是这样的： １、在工作目录中添加、修改文件； ２、将需要进行版本管理的文件放入暂存区域； ３、将暂存区域的文件提交到git仓库。 因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed) ","date":"2021-09-06","objectID":"/git/:3:0","tags":null,"title":"Git","uri":"/git/"},{"categories":null,"content":"Git 项目搭建 本地仓库搭建 创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。 1、创建全新的仓库，需要用GIT管理的项目的根目录执行： # 在当前目录新建一个Git代码库 $ git init 2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。 克隆远程仓库 1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！ 2、去 gitee 或者 github 上克隆一个测试！ # 克隆一个项目和它的整个代码历史(版本信息) $ git clone [url] eg: git clone https://github.com/Yhai-Young/LiveChat.git ","date":"2021-09-06","objectID":"/git/:4:0","tags":null,"title":"Git","uri":"/git/"},{"categories":null,"content":"Git文件操作 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add状态变为**Staged ** Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified . 如果使用git rm 移出版本库, 则成为Untracked 文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add 可进入暂存Staged 状态, 使用git checkout 则丢弃修改过, 返回到unmodify 状态,这个git checkout 即从库中取出文件, 覆盖当前修改 Staged: 暂存状态. 执行git commit 则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify 状态. 执行git reset HEAD filename 取消暂存, 文件状态为Modified # 查看文件状态 git status [filename] # 查看所有文件状态 git status # 忽略文件 有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等 在主目录下建立\".gitignore\"文件，此文件有如下规则： 1. 忽略文件中的空行或以井号（#）开始的行将会被忽略。 2. 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括（{string1,string2,...}）代表可选的字符串等。 3. 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。 4. 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。 5. 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 # 为注释 *.txt #忽略所有 .txt结尾的文件 !lib.txt #但lib.txt除外 /temp #仅忽略项目根目录下的TODO文件,不包括其它目录temp build/ #忽略build/目录下的所有文件 doc/*.txt #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt ","date":"2021-09-06","objectID":"/git/:5:0","tags":null,"title":"Git","uri":"/git/"},{"categories":null,"content":"Intel 集成Git # 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 新建一个分支，但依然停留在当前分支 git branch [branch-name] # 新建一个分支，并切换到该分支 git checkout -b [branch] # 合并指定分支到当前分支 $ git merge [branch] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] ","date":"2021-09-06","objectID":"/git/:6:0","tags":null,"title":"Git","uri":"/git/"}]